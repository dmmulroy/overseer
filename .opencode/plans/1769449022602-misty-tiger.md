# VCS Integration Code Review - Fix Plan

## Summary
Three code review agents analyzed the VCS lifecycle integration. The Oracle verified each finding against source code. **10 findings confirmed, 1 false positive, 4 partial/nuanced.**

## Findings by Severity

### CRITICAL (Fix First)

| # | Issue | File:Line | Verified |
|---|-------|-----------|----------|
| 1 | `complete()` doesn't check if task already completed before VCS ops | `workflow_service.rs:50` | TRUE |
| 2 | `squash().or_else(|_| commit())` swallows all errors including serious ones | `workflow_service.rs:56` | TRUE |

### HIGH (Fix Soon)

| # | Issue | File:Line | Verified |
|---|-------|-----------|----------|
| 3 | `rebase_onto(parent_bookmark)` semantics unclear - may be inverted | `workflow_service.rs:58-62` | PARTIAL |
| 4 | `complete_milestone()` not exposed via CLI - milestones skip cleanup | `task.rs:202-204` | TRUE |
| 5 | `start()` doesn't check if task already started | `workflow_service.rs:30` | TRUE |
| 6 | DB update after VCS ops - no atomicity | `workflow_service.rs:67` | TRUE |
| 7 | `complete_milestone()` rebase loop on children is semantically wrong | `workflow_service.rs:78-84` | TRUE |

### MEDIUM (Consider)

| # | Issue | File:Line | Verified |
|---|-------|-----------|----------|
| 8 | Schema migration not transactional | `schema.rs:64-69` | TRUE |
| 9 | Delete calls `cleanup_bookmark()` before `svc.delete()` | `task.rs:208-210` | TRUE |
| 10 | Git squash may corrupt merge commits | `git.rs:473` | PARTIAL |

### LOW (Backlog)

| # | Issue | File:Line | Verified |
|---|-------|-----------|----------|
| 11 | `unwrap_or_default()` on `current_dir()` silently disables VCS | `main.rs:100` | TRUE |
| 12 | `root()` returns "" for non-UTF8 paths | `git.rs:38`, `jj.rs:81` | TRUE |
| 13 | Git/JJ squash semantics differ | N/A | PARTIAL |

### FALSE POSITIVE

| # | Issue | Reason |
|---|-------|--------|
| 12 | WIP commit created even if working copy is clean | Both backends return NothingToCommit when clean |

---

## Fix Plan (Priority Order)

### Phase 1: Critical Guards (Small, High Impact)

**1. Add completed guard to `complete()`**
```rust
// workflow_service.rs:51
pub fn complete(&self, id: &TaskId, result: Option<&str>) -> Result<Task> {
    let task = self.task_service.get(id)?;
    if task.completed {
        return Ok(task);  // Idempotent
    }
    // ... rest
}
```

**2. Add started guard to `start()`**
```rust
// workflow_service.rs:31
pub fn start(&self, id: &TaskId) -> Result<Task> {
    let task = self.task_service.get(id)?;  // Get first to check state
    if task.started_at.is_some() {
        return Ok(task);  // Idempotent
    }
    let task = self.task_service.start(id)?;
    // ... VCS ops
}
```

**3. Pattern-match squash errors**
```rust
// workflow_service.rs:56
let _ = match vcs.squash(&msg) {
    Ok(result) => Ok(result),
    Err(VcsError::NothingToCommit) => vcs.commit(&msg),
    Err(VcsError::OperationFailed(msg)) if msg.contains("Not enough commits") => vcs.commit(&msg),
    Err(e) => Err(e),  // Propagate serious errors (but still use let _ = for now)
};
```

### Phase 2: Semantic Fixes (Medium Effort)

**4. Auto-detect milestone in `complete()`**
```rust
// workflow_service.rs - modify complete() to auto-call complete_milestone
pub fn complete(&self, id: &TaskId, result: Option<&str>) -> Result<Task> {
    let task = self.task_service.get(id)?;
    if task.completed { return Ok(task); }
    
    // Auto-detect milestone
    if task.depth == Some(0) {
        return self.complete_milestone(id, result);
    }
    // ... regular complete
}
```

**5. Reorder DB/VCS ops in `complete()`**
```rust
// Do DB first (can fail safely), VCS second (best-effort)
pub fn complete(&self, id: &TaskId, result: Option<&str>) -> Result<Task> {
    let task = self.task_service.get(id)?;
    if task.completed { return Ok(task); }
    
    // DB first - this can fail, safe rollback
    let completed_task = self.task_service.complete(id, result)?;
    
    // VCS second - best effort, already committed to DB
    if let Some(ref vcs) = self.vcs {
        // ... squash, rebase
    }
    
    Ok(completed_task)
}
```

**6. Reverse delete order**
```rust
// task.rs:208-210
TaskCommand::Delete { id } => {
    svc.delete(&id)?;  // DB first - validates constraints
    workflow.cleanup_bookmark(&id)?;  // VCS cleanup after
    Ok(TaskResult::Deleted)
}
```

### Phase 3: Design Questions (Need Clarification)

**7. `rebase_onto(parent_bookmark)` semantics**
- Current: Rebases child WC onto parent bookmark
- Question: Is intent to update parent to include child work?
- If yes: Need `move_bookmark(parent_bookmark, child_commit)` instead
- If no: Document that rebase is for forward-porting child

**8. `complete_milestone()` loop**
- Current: Sequential rebase onto each child (overwrites previous)
- Options:
  a) Octopus merge all children
  b) Linear rebase in order (sort by completion time)
  c) Don't rebase, just delete child bookmarks
- Recommendation: Option (c) for now - just cleanup, let user manage merge

### Phase 4: Low Priority

**9. Transactional migration**
```rust
// schema.rs:64
if current_version == 1 {
    conn.execute_batch(r#"
        BEGIN;
        ALTER TABLE tasks ADD COLUMN bookmark TEXT;
        ALTER TABLE tasks ADD COLUMN start_commit TEXT;
        COMMIT;
    "#)?;
    conn.pragma_update(None, "user_version", 2)?;
}
```

**10. Merge commit guard for Git squash**
```rust
// git.rs - add before squash logic
let parent_count = head_commit.parent_ids().count();
if parent_count > 1 {
    return Err(VcsError::OperationFailed("Cannot squash merge commits".to_string()));
}
```

---

## Unresolved Questions

1. **complete() rebase intent**: Forward-port child onto parent, or merge child INTO parent?
2. **complete_milestone() desired behavior**: What should happen with multiple completed children?
3. **Idempotency policy**: Should start/complete be strictly idempotent (return existing) or error on re-call?

---

## Verification

After fixes:
1. `cargo test` - all existing tests pass
2. Manual test: Create task, start, complete, verify VCS state
3. Manual test: Create milestone with children, complete children, complete milestone
4. Manual test: Try to start/complete same task twice - verify idempotent
5. Manual test: Delete task with bookmark - verify cleanup order
